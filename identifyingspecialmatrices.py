# -*- coding: utf-8 -*-
"""Копия блокнота "Copy of IdentifyingSpecialMatrices.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nf3WPAuQSZIsRujFKeNj5KWACAjSS0Pe

# Определение сингулярности матрицы
## Инструкции

В этом задании вы напишете функцию, которая будет проверять перед вычислением матрицы  4×4, не будет ли она сингулярной, то есть, существует ли к ней инверсия.

Вы реализуете метод преобразования матрицы к треугольной форме и проверку: можно ли удалить нули на главной диагонали.
Не беспокойтесь, если вы раньше не программировали, фреймворк для функции уже написан.

В коде отмечены места, где надо внести изменения.
Функции для первых двух строк уже написаны, можно использовать их как подсказку, чтобы сделать функции для двух последних.

### Матрицы в Python
В пакете *numpy* в Python индексация матриц начинается с нуля для самого верхнего столбца и самой левой строки.
Т.е. матричная структура выглядит так:

```python
A[0, 0]  A[0, 1]  A[0, 2]  A[0, 3]
A[1, 0]  A[1, 1]  A[1, 2]  A[1, 3]
A[2, 0]  A[2, 1]  A[2, 2]  A[2, 3]
A[3, 0]  A[3, 1]  A[3, 2]  A[3, 3]
```
Вы можете получить доступ к значению каждого элемента в отдельности, используя
```python
A[n, m]
```
который даст n-ую строку и m-й столбец (начиная с нуля).

Вы также можете получить доступ ко всей строке, используя
```python
A[n]
```
как вы увидите, это будет полезно при расчете линейных комбинаций строк.

Последнее примечание - Python чувствителен к отступам.
Весь код, который надо написать, должен быть на том же уровне отступа, что и комментарий с инструкциями.

Пожалуйста, не меняйте имена функций.
Удачи!
"""

# GRADED FUNCTION
import numpy as np

# Наша функция будет проходить через матрицу, изменяя каждую строку так, чтобы привести матрицу к эшелонированной форме.
# Если в какой-то момент она не сможет поставить 1 в главную диагональ,
# мы вернем значение True, в противном случае мы вернем False.
# Эту функцию изменять не надо.


def isSingular(A) :
    B = np.array(A, dtype=np.float_) #  Делает B как копию матрицы A, так как мы будем менять ее значения.
    try:
        fixRowZero(B)
        fixRowOne(B)
        fixRowTwo(B)
        fixRowThree(B)
    except MatrixIsSingular:
        return True
    return False

# Следующая строка определяет наш флаг ошибки, когда что-то идет не так, и это значит матрица сингулярная.
# Нет необходимости редактировать эту строку.
class MatrixIsSingular(Exception): pass

# Для нулевой строки все, что нам нужно - это сделать нулевой элемент A[0,0] равным 1.
# Для этого мы разделим всю строку на значение A[0,0].
# Однако, если A[0,0] = 0, это вызовет ошибку деления на ноль, поэтому сначала мы его проверим,
# и если это так, то перед делением мы прибавим одну из нижних строк к этой нулевой строке. 
# Если это не поможет, будем повторять такую проверку для каждой следущей строки до тех пор, пока деление не станет возможным. 
# Если так и не найдем нужную строку, значит, матрица сингулярна
# Эта функция уже готова, не редактируйте ее.
def fixRowZero(A):
    if A[0,0] == 0 :
        A[0] = A[0] + A[1]
    if A[0,0] == 0 :
        A[0] = A[0] + A[2]
    if A[0,0] == 0 :
        A[0] = A[0] + A[3]
    if A[0,0] == 0 :
        raise MatrixIsSingular()
    A[0] = A[0] / A[0,0]
    return A

# Сначала мы установим элементы (то есть A[1,0]) под главной диагональю в ноль.
# Далее нам надо, чтобы элемент на диагонали был равен единице, и мы разделим строку на значение A[1,1].
# Опять же, нам нужно проверять, не ноль ли A[1,1].
# Если это так, мы прибавим нижнюю строку и повторим установку поддиагональных элементов в ноль.
# Нет необходимости редактировать эту функцию.
def fixRowOne(A) :
    A[1] = A[1] - A[1,0] * A[0]
    if A[1,1] == 0 :
        A[1] = A[1] + A[2]
        A[1] = A[1] - A[1,0] * A[0]
    if A[1,1] == 0 :
        A[1] = A[1] + A[3]
        A[1] = A[1] - A[1,0] * A[0]
    if A[1,1] == 0 :
        raise MatrixIsSingular()
    A[1] = A[1] / A[1,1]
    return A

# Это первая функция, которую вы напишете самостоятельно.
# Следуйте инструкциям внутри функции
def fixRowTwo(A) :
    A[2] = A[2] - A[2,0] * A[0]
    A[2] = A[2] - A[2,1] * A[1] 
    if A[2,2] == 0 :
        A[2] = A[2] + A[3]
        A[2] = A[2] - A[2,0] * A[0]
        A[2] = A[2] - A[2,1] * A[1]
    if A[2,2] == 0 :
        raise MatrixIsSingular()
    A[2] = A[2] / A[2,2]
    return A

# Эта функция, которую вы так же напишете самостоятельно
# Следуйте инструкциям внутри функции.
def fixRowThree(A) :
    A[3] = A[3] - A[3,0] * A[0]
    A[3] = A[3] - A[3,1] * A[1]
    A[3] = A[3] - A[3,2] * A[2]
    if A[3,3] == 0:
        raise MatrixIsSingular()
    A[3] = A[3] / A[3,3]
    
    return A

"""## Проверьте свой код перед отправкой
Чтобы проверить код, который вы написали выше, запустите ячейку (выберите ячейку выше, затем нажмите кнопку воспроизведения [▶ |] или нажмите Shift-Enter).
Затем вы можете использовать приведенный ниже код для проверки вашей функции.
Эта ячейка не оценивается; можете изменять и запускать ее сколько угодно.

Попробуйте свой код на других сложных тестовых матрицах.

"""

A = np.array([
        [2, 0, 0, 0],
        [0, 3, 0, 0],
        [0, 0, 4, 4],
        [0, 0, 5, 5]
    ], dtype=np.float_)
isSingular(A)

A = np.array([
        [0, 7, -5, 3],
        [2, 8, 0, 4],
        [3, 12, 0, 5],
        [1, 3, 1, 3]
    ], dtype=np.float_)
fixRowZero(A)

fixRowOne(A)

fixRowTwo(A)

fixRowThree(A)